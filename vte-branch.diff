diff -urN vte-0.16.0/ChangeLog vte-1846/ChangeLog
--- vte-0.16.0/ChangeLog	2007-03-13 00:18:36.000000000 +0100
+++ vte-1846/ChangeLog	2007-03-18 13:22:43.000000000 +0100
@@ -1,3 +1,84 @@
+2007-03-16  Chris Wilson  <chris@chris-wilson.co.uk>
+
+	Need to trigger update timeout rather than process timeout
+	otherwise the background is not updated.
+
+	* src/vte.c (vte_terminal_queue_adjustment_changed),
+	(vte_terminal_queue_adjustment_value_changed):
+
+2007-03-16  Chris Wilson  <chris@chris-wilson.co.uk>
+
+	* src/vtexft.c (_vte_xft_create), (_vte_xft_destroy),
+	(_vte_xft_start), (_vte_xft_end), (_vte_xft_clip),
+	(_vte_xft_clear): Avoid some allocations.
+
+2007-03-16  Chris Wilson  <chris@chris-wilson.co.uk>
+
+	Bug 418073 â€“ Opacity ignored for vtexft
+
+	* src/vte.c:
+	* src/vtedraw.c (_vte_draw_requires_clear):
+	* src/vtedraw.h:
+	* src/vteft2.c (_vte_ft2_set_background_image):
+	* src/vtegl.c (_vte_gl_create), (_vte_gl_set_background_image):
+	* src/vtepango.c (_vte_pango_set_background_image):
+	* src/vtepangox.c (_vte_pango_x_set_background_image):
+	* src/vtexft.c (_vte_xft_set_background_color),
+	(_vte_xft_set_background_image):
+		Flood fill the backing pixmap if we need to change it's
+		opacity as well.
+
+2007-03-16  Chris Wilson  <chris@chris-wilson.co.uk>
+
+	Bug 418910 â€“ Asymmetric scrolling with mouse wheel
+
+	* configure.in:
+	* src/vte.c: Round-up the delta before applying to ensure consistency
+	between up and down.
+
+2007-03-16  Chris Wilson  <chris@chris-wilson.co.uk>
+
+	* src/vte.c (vte_terminal_catch_child_exited), (vte_terminal_eof),
+	(vte_terminal_process_incoming): Refactor some common code.
+
+2007-03-16  Chris Wilson  <chris@chris-wilson.co.uk>
+
+	Bug 416634 â€“ Rendering glitch as autowrapped chars are outside invalidated bbox
+
+	* src/vte.c (_vte_terminal_insert_char),
+	(vte_terminal_process_incoming): Correctly update bbox after
+	autowrapping.
+
+2007-03-16  Chris Wilson  <chris@chris-wilson.co.uk>
+
+	Bug 416635 â€“ Rendering glitch: double draw of line below exposed region
+
+	* src/vte.c (vte_terminal_expand_region),
+	(vte_terminal_paint_area): Kill a couple of off-by-ones.
+
+2007-03-16  Chris Wilson  <chris@chris-wilson.co.uk>
+
+	Bug 418588 â€“ Invalid read when drawing preedit cursor
+
+	* src/vte.c (vte_terminal_paint):
+		No need to read what is drawn and furthermore isn't allocated.
+
+2007-03-16  Chris Wilson  <chris@chris-wilson.co.uk>
+
+	Bug 417652 â€“ Scrolling bug exposed by nvi
+
+	* src/vte.c (vte_terminal_insert_rows), (_vte_terminal_ensure_row),
+	(vte_terminal_ensure_cursor), (_vte_terminal_update_insert_delta):
+		Ensure the rows before updating the insert delta and refactor
+		the common code.
+
+2007-03-16  Chris Wilson  <chris@chris-wilson.co.uk>
+
+	Bug 417301 â€“ Terminal widgets don't respond to DPI changes
+
+	* src/vte.c (vte_terminal_fc_settings_changed): Force a font reload
+	after XFT settings have changed.
+
 2007-03-12  Behdad Esfahbod  <behdad@gnome.org>
 
 	Released vte-0.16.0.
diff -urN vte-0.16.0/po/Makefile.in.in vte-1846/po/Makefile.in.in
--- vte-0.16.0/po/Makefile.in.in	2007-02-26 22:05:39.000000000 +0100
+++ vte-1846/po/Makefile.in.in	1970-01-01 01:00:00.000000000 +0100
@@ -1,221 +0,0 @@
-# Makefile for program source directory in GNU NLS utilities package.
-# Copyright (C) 1995, 1996, 1997 by Ulrich Drepper <drepper@gnu.ai.mit.edu>
-#
-# This file file be copied and used freely without restrictions.  It can
-# be used in projects which are not available under the GNU Public License
-# but which still want to provide support for the GNU gettext functionality.
-# Please note that the actual code is *not* freely available.
-#
-# - Modified by Owen Taylor <otaylor@redhat.com> to use GETTEXT_PACKAGE
-#   instead of PACKAGE and to look for po2tbl in ./ not in intl/
-#
-# - Modified by jacob berkman <jacob@ximian.com> to install
-#   Makefile.in.in and po2tbl.sed.in for use with glib-gettextize
-#
-# - Modified by Rodney Dawes <dobey@novell.com> for use with intltool
-#
-# We have the following line for use by intltoolize:
-# INTLTOOL_MAKEFILE
-
-GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
-PACKAGE = @PACKAGE@
-VERSION = @VERSION@
-
-SHELL = /bin/sh
-
-srcdir = @srcdir@
-top_srcdir = @top_srcdir@
-top_builddir = ..
-VPATH = @srcdir@
-
-prefix = @prefix@
-exec_prefix = @exec_prefix@
-datadir = @datadir@
-datarootdir = @datarootdir@
-libdir = @libdir@
-DATADIRNAME = @DATADIRNAME@
-itlocaledir = $(prefix)/$(DATADIRNAME)/locale
-subdir = po
-install_sh = @install_sh@
-# Automake >= 1.8 provides @mkdir_p@.
-# Until it can be supposed, use the safe fallback:
-mkdir_p = $(install_sh) -d
-
-INSTALL = @INSTALL@
-INSTALL_DATA = @INSTALL_DATA@
-
-GMSGFMT = @GMSGFMT@
-MSGFMT = @MSGFMT@
-XGETTEXT = @XGETTEXT@
-INTLTOOL_UPDATE = @INTLTOOL_UPDATE@
-INTLTOOL_EXTRACT = @INTLTOOL_EXTRACT@
-MSGMERGE = INTLTOOL_EXTRACT=$(INTLTOOL_EXTRACT) srcdir=$(srcdir) $(INTLTOOL_UPDATE) --gettext-package $(GETTEXT_PACKAGE) --dist
-GENPOT   = INTLTOOL_EXTRACT=$(INTLTOOL_EXTRACT) srcdir=$(srcdir) $(INTLTOOL_UPDATE) --gettext-package $(GETTEXT_PACKAGE) --pot
-
-ALL_LINGUAS = @ALL_LINGUAS@
-
-PO_LINGUAS=$(shell if test -r $(srcdir)/LINGUAS; then grep -v "^\#" $(srcdir)/LINGUAS; fi)
-
-POFILES=$(shell if test -n "$(PO_LINGUAS)"; then LINGUAS="$(PO_LINGUAS)"; else LINGUAS="$(ALL_LINGUAS)"; fi; for lang in $$LINGUAS; do printf "$$lang.po "; done)
-
-DISTFILES = ChangeLog Makefile.in.in POTFILES.in $(POFILES)
-EXTRA_DISTFILES = POTFILES.skip Makevars LINGUAS
-
-POTFILES = \
-#This Gets Replace for some reason
-
-CATALOGS=$(shell if test -n "$(PO_LINGUAS)"; then LINGUAS="$(PO_LINGUAS)"; else LINGUAS="$(ALL_LINGUAS)"; fi; for lang in $$LINGUAS; do printf "$$lang.gmo "; done)
-
-.SUFFIXES:
-.SUFFIXES: .po .pox .gmo .mo .msg .cat
-
-.po.pox:
-	$(MAKE) $(GETTEXT_PACKAGE).pot
-	$(MSGMERGE) $< $(GETTEXT_PACKAGE).pot -o $*.pox
-
-.po.mo:
-	$(MSGFMT) -o $@ $<
-
-.po.gmo:
-	file=`echo $* | sed 's,.*/,,'`.gmo \
-	  && rm -f $$file && $(GMSGFMT) -o $$file $<
-
-.po.cat:
-	sed -f ../intl/po2msg.sed < $< > $*.msg \
-	  && rm -f $@ && gencat $@ $*.msg
-
-
-all: all-@USE_NLS@
-
-all-yes: $(CATALOGS)
-all-no:
-
-$(GETTEXT_PACKAGE).pot: $(POTFILES)
-	$(GENPOT)
-
-install: install-data
-install-data: install-data-@USE_NLS@
-install-data-no: all
-install-data-yes: all
-	$(mkdir_p) $(DESTDIR)$(itlocaledir)
-	if test -n "$(PO_LINGUAS)"; then \
-	  linguas="$(PO_LINGUAS)"; \
-	else \
-	  linguas="$(ALL_LINGUAS)"; \
-	fi; \
-	for lang in $$linguas; do \
-	  dir=$(DESTDIR)$(itlocaledir)/$$lang/LC_MESSAGES; \
-	  $(mkdir_p) $$dir; \
-	  if test -r $$lang.gmo; then \
-	    $(INSTALL_DATA) $$lang.gmo $$dir/$(GETTEXT_PACKAGE).mo; \
-	    echo "installing $$lang.gmo as $$dir/$(GETTEXT_PACKAGE).mo"; \
-	  else \
-	    $(INSTALL_DATA) $(srcdir)/$$lang.gmo $$dir/$(GETTEXT_PACKAGE).mo; \
-	    echo "installing $(srcdir)/$$lang.gmo as" \
-		 "$$dir/$(GETTEXT_PACKAGE).mo"; \
-	  fi; \
-	  if test -r $$lang.gmo.m; then \
-	    $(INSTALL_DATA) $$lang.gmo.m $$dir/$(GETTEXT_PACKAGE).mo.m; \
-	    echo "installing $$lang.gmo.m as $$dir/$(GETTEXT_PACKAGE).mo.m"; \
-	  else \
-	    if test -r $(srcdir)/$$lang.gmo.m ; then \
-	      $(INSTALL_DATA) $(srcdir)/$$lang.gmo.m \
-		$$dir/$(GETTEXT_PACKAGE).mo.m; \
-	      echo "installing $(srcdir)/$$lang.gmo.m as" \
-		   "$$dir/$(GETTEXT_PACKAGE).mo.m"; \
-	    else \
-	      true; \
-	    fi; \
-	  fi; \
-	done
-
-# Empty stubs to satisfy archaic automake needs
-dvi info tags TAGS ID:
-
-# Define this as empty until I found a useful application.
-installcheck:
-
-uninstall:
-	if test -n "$(PO_LINGUAS)"; then \
-	  linguas="$(PO_LINGUAS)"; \
-	else \
-	  linguas="$(ALL_LINGUAS)"; \
-	fi; \
-	for lang in $$linguas; do \
-	  rm -f $(DESTDIR)$(itlocaledir)/$$lang/LC_MESSAGES/$(GETTEXT_PACKAGE).mo; \
-	  rm -f $(DESTDIR)$(itlocaledir)/$$lang/LC_MESSAGES/$(GETTEXT_PACKAGE).mo.m; \
-	done
-
-check: all $(GETTEXT_PACKAGE).pot
-
-mostlyclean:
-	rm -f *.pox $(GETTEXT_PACKAGE).pot *.old.po cat-id-tbl.tmp
-	rm -f .intltool-merge-cache
-
-clean: mostlyclean
-
-distclean: clean
-	rm -f Makefile Makefile.in POTFILES stamp-it
-	rm -f *.mo *.msg *.cat *.cat.m *.gmo
-
-maintainer-clean: distclean
-	@echo "This command is intended for maintainers to use;"
-	@echo "it deletes files that may require special tools to rebuild."
-	rm -f Makefile.in.in
-
-distdir = ../$(PACKAGE)-$(VERSION)/$(subdir)
-dist distdir: $(DISTFILES)
-	dists="$(DISTFILES)"; \
-	extra_dists="$(EXTRA_DISTFILES)"; \
-	for file in $$extra_dists; do \
-	  test -f $(srcdir)/$$file && dists="$$dists $(srcdir)/$$file"; \
-	done; \
-	for file in $$dists; do \
-	  test -f $$file || file="$(srcdir)/$$file"; \
-	  ln $$file $(distdir) 2> /dev/null \
-	    || cp -p $$file $(distdir); \
-	done
-
-update-po: Makefile
-	$(MAKE) $(GETTEXT_PACKAGE).pot
-	tmpdir=`pwd`; \
-	if test -n "$(PO_LINGUAS)"; then \
-	  linguas="$(PO_LINGUAS)"; \
-	else \
-	  linguas="$(ALL_LINGUAS)"; \
-	fi; \
-	for lang in $$linguas; do \
-	  echo "$$lang:"; \
-	  result="`$(MSGMERGE) -o $$tmpdir/$$lang.new.po $$lang`"; \
-	  if $$result; then \
-	    if cmp $(srcdir)/$$lang.po $$tmpdir/$$lang.new.po >/dev/null 2>&1; then \
-	      rm -f $$tmpdir/$$lang.new.po; \
-            else \
-	      if mv -f $$tmpdir/$$lang.new.po $$lang.po; then \
-	        :; \
-	      else \
-	        echo "msgmerge for $$lang.po failed: cannot move $$tmpdir/$$lang.new.po to $$lang.po" 1>&2; \
-	        rm -f $$tmpdir/$$lang.new.po; \
-	        exit 1; \
-	      fi; \
-	    fi; \
-	  else \
-	    echo "msgmerge for $$lang.gmo failed!"; \
-	    rm -f $$tmpdir/$$lang.new.po; \
-	  fi; \
-	done
-
-Makefile POTFILES: stamp-it
-	@if test ! -f $@; then \
-	  rm -f stamp-it; \
-	  $(MAKE) stamp-it; \
-	fi
-
-stamp-it: Makefile.in.in ../config.status POTFILES.in
-	cd .. \
-	  && CONFIG_FILES=$(subdir)/Makefile.in CONFIG_HEADERS= CONFIG_LINKS= \
-	       $(SHELL) ./config.status
-
-# Tell versions [3.59,3.63) of GNU make not to export all variables.
-# Otherwise a system limit (for SysV at least) may be exceeded.
-.NOEXPORT:
diff -urN vte-0.16.0/src/cp437.py vte-1846/src/cp437.py
--- vte-0.16.0/src/cp437.py	1970-01-01 01:00:00.000000000 +0100
+++ vte-1846/src/cp437.py	2007-03-18 13:22:32.000000000 +0100
@@ -0,0 +1,9 @@
+#!/usr/bin/python
+print '%s' % '(U'
+i = 128
+while (i < 256):
+	print "%c" % i,
+	if ((i % 32) == 31):
+		print ""
+	i = i + 1
+print '%s' % '(B)0*B+B'
diff -urN vte-0.16.0/src/genwidths.py vte-1846/src/genwidths.py
--- vte-0.16.0/src/genwidths.py	1970-01-01 01:00:00.000000000 +0100
+++ vte-1846/src/genwidths.py	2007-03-18 13:22:32.000000000 +0100
@@ -0,0 +1,35 @@
+#!/usr/bin/python
+import os, re, string
+
+try:
+	unidata = open("EastAsianWidth.txt", "r")
+except:
+	os.system("wget --passive-ftp -c ftp://ftp.unicode.org/Public/UNIDATA/EastAsianWidth.txt")
+	unidata = open("EastAsianWidth.txt", "r")
+out = open("uniwidths", "w")
+ranges = []
+specifics = []
+rangere = re.compile("^([0123456789ABCDEF]+)\.\.([0123456789ABCDEF]+);A")
+specificre = re.compile("^([0123456789ABCDEF]+);A")
+for line in unidata.readlines():
+	match = re.match(specificre, line)
+	if match:
+		if match.groups().__len__() > 0:
+			specifics.append(match.groups()[0])
+	match = re.match(rangere, line)
+	if match:
+		if match.groups().__len__() > 1:
+			ranges.append((match.groups()[0], match.groups()[1]))
+
+print >> out, "static const struct {"
+print >> out, "\tgunichar start, end;"
+print >> out, "} _vte_iso2022_ambiguous_ranges[] = {"
+for range in ranges:
+	print >> out, "\t{0x%x, 0x%x}," % (string.atol(range[0], 16), string.atol(range[1], 16))
+print >> out, "};"
+
+print >> out, "static const gunichar _vte_iso2022_ambiguous_chars[] = {"
+for specific in specifics:
+	print >> out, "\t0x%x," % (string.atol(specific, 16))
+print >> out, "};"
+
diff -urN vte-0.16.0/src/marshal.c vte-1846/src/marshal.c
--- vte-0.16.0/src/marshal.c	2007-02-26 22:06:36.000000000 +0100
+++ vte-1846/src/marshal.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,203 +0,0 @@
-
-#include	<glib-object.h>
-
-
-#ifdef G_ENABLE_DEBUG
-#define g_marshal_value_peek_boolean(v)  g_value_get_boolean (v)
-#define g_marshal_value_peek_char(v)     g_value_get_char (v)
-#define g_marshal_value_peek_uchar(v)    g_value_get_uchar (v)
-#define g_marshal_value_peek_int(v)      g_value_get_int (v)
-#define g_marshal_value_peek_uint(v)     g_value_get_uint (v)
-#define g_marshal_value_peek_long(v)     g_value_get_long (v)
-#define g_marshal_value_peek_ulong(v)    g_value_get_ulong (v)
-#define g_marshal_value_peek_int64(v)    g_value_get_int64 (v)
-#define g_marshal_value_peek_uint64(v)   g_value_get_uint64 (v)
-#define g_marshal_value_peek_enum(v)     g_value_get_enum (v)
-#define g_marshal_value_peek_flags(v)    g_value_get_flags (v)
-#define g_marshal_value_peek_float(v)    g_value_get_float (v)
-#define g_marshal_value_peek_double(v)   g_value_get_double (v)
-#define g_marshal_value_peek_string(v)   (char*) g_value_get_string (v)
-#define g_marshal_value_peek_param(v)    g_value_get_param (v)
-#define g_marshal_value_peek_boxed(v)    g_value_get_boxed (v)
-#define g_marshal_value_peek_pointer(v)  g_value_get_pointer (v)
-#define g_marshal_value_peek_object(v)   g_value_get_object (v)
-#else /* !G_ENABLE_DEBUG */
-/* WARNING: This code accesses GValues directly, which is UNSUPPORTED API.
- *          Do not access GValues directly in your code. Instead, use the
- *          g_value_get_*() functions
- */
-#define g_marshal_value_peek_boolean(v)  (v)->data[0].v_int
-#define g_marshal_value_peek_char(v)     (v)->data[0].v_int
-#define g_marshal_value_peek_uchar(v)    (v)->data[0].v_uint
-#define g_marshal_value_peek_int(v)      (v)->data[0].v_int
-#define g_marshal_value_peek_uint(v)     (v)->data[0].v_uint
-#define g_marshal_value_peek_long(v)     (v)->data[0].v_long
-#define g_marshal_value_peek_ulong(v)    (v)->data[0].v_ulong
-#define g_marshal_value_peek_int64(v)    (v)->data[0].v_int64
-#define g_marshal_value_peek_uint64(v)   (v)->data[0].v_uint64
-#define g_marshal_value_peek_enum(v)     (v)->data[0].v_long
-#define g_marshal_value_peek_flags(v)    (v)->data[0].v_ulong
-#define g_marshal_value_peek_float(v)    (v)->data[0].v_float
-#define g_marshal_value_peek_double(v)   (v)->data[0].v_double
-#define g_marshal_value_peek_string(v)   (v)->data[0].v_pointer
-#define g_marshal_value_peek_param(v)    (v)->data[0].v_pointer
-#define g_marshal_value_peek_boxed(v)    (v)->data[0].v_pointer
-#define g_marshal_value_peek_pointer(v)  (v)->data[0].v_pointer
-#define g_marshal_value_peek_object(v)   (v)->data[0].v_pointer
-#endif /* !G_ENABLE_DEBUG */
-
-
-/* VOID:VOID (marshal.list:1) */
-
-/* VOID:STRING (marshal.list:2) */
-
-/* VOID:STRING,UINT (marshal.list:3) */
-void
-_vte_marshal_VOID__STRING_UINT (GClosure     *closure,
-                                GValue       *return_value,
-                                guint         n_param_values,
-                                const GValue *param_values,
-                                gpointer      invocation_hint,
-                                gpointer      marshal_data)
-{
-  typedef void (*GMarshalFunc_VOID__STRING_UINT) (gpointer     data1,
-                                                  gpointer     arg_1,
-                                                  guint        arg_2,
-                                                  gpointer     data2);
-  register GMarshalFunc_VOID__STRING_UINT callback;
-  register GCClosure *cc = (GCClosure*) closure;
-  register gpointer data1, data2;
-
-  g_return_if_fail (n_param_values == 3);
-
-  if (G_CCLOSURE_SWAP_DATA (closure))
-    {
-      data1 = closure->data;
-      data2 = g_value_peek_pointer (param_values + 0);
-    }
-  else
-    {
-      data1 = g_value_peek_pointer (param_values + 0);
-      data2 = closure->data;
-    }
-  callback = (GMarshalFunc_VOID__STRING_UINT) (marshal_data ? marshal_data : cc->callback);
-
-  callback (data1,
-            g_marshal_value_peek_string (param_values + 1),
-            g_marshal_value_peek_uint (param_values + 2),
-            data2);
-}
-
-/* VOID:INT (marshal.list:4) */
-
-/* VOID:INT,INT (marshal.list:5) */
-void
-_vte_marshal_VOID__INT_INT (GClosure     *closure,
-                            GValue       *return_value,
-                            guint         n_param_values,
-                            const GValue *param_values,
-                            gpointer      invocation_hint,
-                            gpointer      marshal_data)
-{
-  typedef void (*GMarshalFunc_VOID__INT_INT) (gpointer     data1,
-                                              gint         arg_1,
-                                              gint         arg_2,
-                                              gpointer     data2);
-  register GMarshalFunc_VOID__INT_INT callback;
-  register GCClosure *cc = (GCClosure*) closure;
-  register gpointer data1, data2;
-
-  g_return_if_fail (n_param_values == 3);
-
-  if (G_CCLOSURE_SWAP_DATA (closure))
-    {
-      data1 = closure->data;
-      data2 = g_value_peek_pointer (param_values + 0);
-    }
-  else
-    {
-      data1 = g_value_peek_pointer (param_values + 0);
-      data2 = closure->data;
-    }
-  callback = (GMarshalFunc_VOID__INT_INT) (marshal_data ? marshal_data : cc->callback);
-
-  callback (data1,
-            g_marshal_value_peek_int (param_values + 1),
-            g_marshal_value_peek_int (param_values + 2),
-            data2);
-}
-
-/* VOID:UINT,UINT (marshal.list:6) */
-void
-_vte_marshal_VOID__UINT_UINT (GClosure     *closure,
-                              GValue       *return_value,
-                              guint         n_param_values,
-                              const GValue *param_values,
-                              gpointer      invocation_hint,
-                              gpointer      marshal_data)
-{
-  typedef void (*GMarshalFunc_VOID__UINT_UINT) (gpointer     data1,
-                                                guint        arg_1,
-                                                guint        arg_2,
-                                                gpointer     data2);
-  register GMarshalFunc_VOID__UINT_UINT callback;
-  register GCClosure *cc = (GCClosure*) closure;
-  register gpointer data1, data2;
-
-  g_return_if_fail (n_param_values == 3);
-
-  if (G_CCLOSURE_SWAP_DATA (closure))
-    {
-      data1 = closure->data;
-      data2 = g_value_peek_pointer (param_values + 0);
-    }
-  else
-    {
-      data1 = g_value_peek_pointer (param_values + 0);
-      data2 = closure->data;
-    }
-  callback = (GMarshalFunc_VOID__UINT_UINT) (marshal_data ? marshal_data : cc->callback);
-
-  callback (data1,
-            g_marshal_value_peek_uint (param_values + 1),
-            g_marshal_value_peek_uint (param_values + 2),
-            data2);
-}
-
-/* VOID:OBJECT,OBJECT (marshal.list:7) */
-void
-_vte_marshal_VOID__OBJECT_OBJECT (GClosure     *closure,
-                                  GValue       *return_value,
-                                  guint         n_param_values,
-                                  const GValue *param_values,
-                                  gpointer      invocation_hint,
-                                  gpointer      marshal_data)
-{
-  typedef void (*GMarshalFunc_VOID__OBJECT_OBJECT) (gpointer     data1,
-                                                    gpointer     arg_1,
-                                                    gpointer     arg_2,
-                                                    gpointer     data2);
-  register GMarshalFunc_VOID__OBJECT_OBJECT callback;
-  register GCClosure *cc = (GCClosure*) closure;
-  register gpointer data1, data2;
-
-  g_return_if_fail (n_param_values == 3);
-
-  if (G_CCLOSURE_SWAP_DATA (closure))
-    {
-      data1 = closure->data;
-      data2 = g_value_peek_pointer (param_values + 0);
-    }
-  else
-    {
-      data1 = g_value_peek_pointer (param_values + 0);
-      data2 = closure->data;
-    }
-  callback = (GMarshalFunc_VOID__OBJECT_OBJECT) (marshal_data ? marshal_data : cc->callback);
-
-  callback (data1,
-            g_marshal_value_peek_object (param_values + 1),
-            g_marshal_value_peek_object (param_values + 2),
-            data2);
-}
-
diff -urN vte-0.16.0/src/marshal.h vte-1846/src/marshal.h
--- vte-0.16.0/src/marshal.h	2007-02-26 22:06:36.000000000 +0100
+++ vte-1846/src/marshal.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,53 +0,0 @@
-
-#ifndef ___vte_marshal_MARSHAL_H__
-#define ___vte_marshal_MARSHAL_H__
-
-#include	<glib-object.h>
-
-G_BEGIN_DECLS
-
-/* VOID:VOID (marshal.list:1) */
-#define _vte_marshal_VOID__VOID	g_cclosure_marshal_VOID__VOID
-
-/* VOID:STRING (marshal.list:2) */
-#define _vte_marshal_VOID__STRING	g_cclosure_marshal_VOID__STRING
-
-/* VOID:STRING,UINT (marshal.list:3) */
-extern void _vte_marshal_VOID__STRING_UINT (GClosure     *closure,
-                                            GValue       *return_value,
-                                            guint         n_param_values,
-                                            const GValue *param_values,
-                                            gpointer      invocation_hint,
-                                            gpointer      marshal_data);
-
-/* VOID:INT (marshal.list:4) */
-#define _vte_marshal_VOID__INT	g_cclosure_marshal_VOID__INT
-
-/* VOID:INT,INT (marshal.list:5) */
-extern void _vte_marshal_VOID__INT_INT (GClosure     *closure,
-                                        GValue       *return_value,
-                                        guint         n_param_values,
-                                        const GValue *param_values,
-                                        gpointer      invocation_hint,
-                                        gpointer      marshal_data);
-
-/* VOID:UINT,UINT (marshal.list:6) */
-extern void _vte_marshal_VOID__UINT_UINT (GClosure     *closure,
-                                          GValue       *return_value,
-                                          guint         n_param_values,
-                                          const GValue *param_values,
-                                          gpointer      invocation_hint,
-                                          gpointer      marshal_data);
-
-/* VOID:OBJECT,OBJECT (marshal.list:7) */
-extern void _vte_marshal_VOID__OBJECT_OBJECT (GClosure     *closure,
-                                              GValue       *return_value,
-                                              guint         n_param_values,
-                                              const GValue *param_values,
-                                              gpointer      invocation_hint,
-                                              gpointer      marshal_data);
-
-G_END_DECLS
-
-#endif /* ___vte_marshal_MARSHAL_H__ */
-
diff -urN vte-0.16.0/src/vte.c vte-1846/src/vte.c
--- vte-0.16.0/src/vte.c	2007-03-08 17:47:15.000000000 +0100
+++ vte-1846/src/vte.c	2007-03-18 13:22:32.000000000 +0100
@@ -18,6 +18,8 @@
 
 #include "../config.h"
 
+#include <math.h>
+
 #include "vte.h"
 #include "vte-private.h"
 
@@ -78,8 +80,7 @@
 static void vte_terminal_match_contents_clear(VteTerminal *terminal);
 static gboolean vte_terminal_background_update(VteTerminal *data);
 static void vte_terminal_queue_background_update(VteTerminal *terminal);
-static void vte_terminal_queue_adjustment_changed(VteTerminal *terminal);
-static gboolean vte_terminal_process_incoming(VteTerminal *terminal);
+static void vte_terminal_process_incoming(VteTerminal *terminal);
 static void vte_terminal_emit_pending_signals(VteTerminal *terminal);
 static inline gboolean vte_cell_is_selected(VteTerminal *terminal,
 				     glong col, glong row, gpointer data);
@@ -1613,19 +1614,19 @@
 }
 
 /* Queue an adjustment-changed signal to be delivered when convenient. */
-static void
+static inline void
 vte_terminal_queue_adjustment_changed(VteTerminal *terminal)
 {
 	terminal->pvt->adjustment_changed_pending = TRUE;
-	vte_terminal_start_processing (terminal);
+	add_update_timeout (terminal);
 }
-static void
+static inline void
 vte_terminal_queue_adjustment_value_changed(VteTerminal *terminal, glong v)
 {
 	if (v != terminal->pvt->screen->scroll_delta) {
 		terminal->pvt->screen->scroll_delta = v;
 		terminal->pvt->adjustment_value_changed_pending = TRUE;
-		vte_terminal_start_processing (terminal);
+		add_update_timeout (terminal);
 	}
 }
 
@@ -1855,13 +1856,32 @@
 	return terminal->pvt->encoding;
 }
 
+static inline VteRowData*
+vte_terminal_insert_rows (VteTerminal *terminal, guint cnt)
+{
+	const VteScreen *screen = terminal->pvt->screen;
+	VteRowData *old_row, *row;
+	old_row = terminal->pvt->free_row;
+	do {
+		if (old_row) {
+			row = _vte_reset_row_data (terminal, old_row, FALSE);
+		} else {
+			row = _vte_new_row_data_sized (terminal, FALSE);
+		}
+		old_row = _vte_ring_append(screen->row_data, row);
+	} while(--cnt);
+	terminal->pvt->free_row = old_row;
+	return row;
+}
+
+
 /* Make sure we have enough rows and columns to hold data at the current
  * cursor position. */
 VteRowData *
 _vte_terminal_ensure_row (VteTerminal *terminal)
 {
 	VteRowData *row;
-	VteScreen *screen;
+	const VteScreen *screen;
 	gint delta;
 	glong v;
 
@@ -1875,18 +1895,7 @@
 		/* Figure out how many rows we need to add. */
 		delta = v - _vte_ring_next(screen->row_data) + 1;
 		if (delta > 0) {
-			VteRowData *old_row;
-
-			old_row = terminal->pvt->free_row;
-			do {
-				if (old_row) {
-					row = _vte_reset_row_data (terminal, old_row, FALSE);
-				} else {
-					row = _vte_new_row_data_sized (terminal, FALSE);
-				}
-				old_row = _vte_ring_append(screen->row_data, row);
-			} while(--delta);
-			terminal->pvt->free_row = old_row;
+			row = vte_terminal_insert_rows (terminal, delta);
 			_vte_terminal_adjust_adjustments(terminal);
 		} else {
 			/* Find the row the cursor is in. */
@@ -1920,18 +1929,7 @@
 		/* Figure out how many rows we need to add. */
 		delta = v - _vte_ring_next(screen->row_data) + 1;
 		if (delta > 0) {
-			VteRowData *old_row;
-
-			old_row = terminal->pvt->free_row;
-			do {
-				if (old_row) {
-					row = _vte_reset_row_data (terminal, old_row, FALSE);
-				} else {
-					row = _vte_new_row_data_sized (terminal, FALSE);
-				}
-				old_row = _vte_ring_append(screen->row_data, row);
-			} while(--delta);
-			terminal->pvt->free_row = old_row;
+			row = vte_terminal_insert_rows (terminal, delta);
 			_vte_terminal_adjust_adjustments(terminal);
 		} else {
 			/* Find the row the cursor is in. */
@@ -1969,8 +1967,12 @@
 
 	/* The total number of lines.  Add one to the cursor offset
 	 * because it's zero-based. */
-	rows = MAX(_vte_ring_next(terminal->pvt->screen->row_data),
-		   terminal->pvt->screen->cursor_current.row + 1);
+	rows = _vte_ring_next (screen->row_data);
+	delta = screen->cursor_current.row - rows + 1;
+	if (G_UNLIKELY (delta > 0)) {
+		vte_terminal_insert_rows (terminal, delta);
+		rows = _vte_ring_next (screen->row_data);
+	}
 
 	/* Make sure that the bottom row is visible, and that it's in
 	 * the buffer (even if it's empty).  This usually causes the
@@ -2444,7 +2446,7 @@
 }
 
 /* Insert a single character into the stored data array. */
-void
+gboolean
 _vte_terminal_insert_char(VteTerminal *terminal, gunichar c,
 			 gboolean force_insert_mode, gboolean invalidate_now,
 			 gboolean paint_cells, gint forced_width)
@@ -2454,6 +2456,7 @@
 	int columns, i;
 	long col;
 	VteScreen *screen;
+	gboolean line_wrapped = FALSE; /* cursor moved before char inserted */
 	gboolean insert;
 
 	screen = terminal->pvt->screen;
@@ -2479,7 +2482,7 @@
 	if (G_UNLIKELY (screen->status_line)) {
 		g_string_append_unichar(screen->status_line_contents, c);
 		screen->status_line_changed = TRUE;
-		return;
+		return FALSE;
 	}
 
 	/* Figure out how many columns this character should occupy. */
@@ -2511,6 +2514,7 @@
 			col = screen->cursor_current.col =
 				terminal->column_count - columns;
 		}
+		line_wrapped = TRUE;
 	}
 
 	/* Make sure we have enough rows to hold this data. */
@@ -2610,6 +2614,7 @@
 	_vte_debug_print(VTE_DEBUG_IO|VTE_DEBUG_PARSE,
 			"insertion delta => %ld.\n",
 			(long)screen->insert_delta);
+	return line_wrapped;
 }
 
 static void
@@ -2730,10 +2735,7 @@
 		 * then flush the buffers in case we're about to run a new
 		 * command, disconnecting the timeout. */
 		if (terminal->pvt->incoming != NULL) {
-			gboolean again;
-			do {
-				again = vte_terminal_process_incoming(terminal);
-			} while (again);
+			vte_terminal_process_incoming(terminal);
 			_vte_incoming_chunks_release (terminal->pvt->incoming);
 			terminal->pvt->incoming = NULL;
 			terminal->pvt->input_bytes = 0;
@@ -3042,12 +3044,8 @@
 	 * disconnecting the timeout. */
 	vte_terminal_stop_processing (terminal);
 	if (terminal->pvt->incoming) {
-		gboolean again;
-		do {
-			again = vte_terminal_process_incoming(terminal);
-		} while (again);
+		vte_terminal_process_incoming(terminal);
 		terminal->pvt->input_bytes = 0;
-		vte_terminal_emit_pending_signals (terminal);
 	}
 	g_array_set_size(terminal->pvt->pending, 0);
 
@@ -3134,7 +3132,7 @@
 
 /* Process incoming data, first converting it to unicode characters, and then
  * processing control sequences. */
-static gboolean
+static void
 vte_terminal_process_incoming(VteTerminal *terminal)
 {
 	VteScreen *screen;
@@ -3244,7 +3242,7 @@
 	bbox_bottomright.x = bbox_bottomright.y = -G_MAXINT;
 	bbox_topleft.x = bbox_topleft.y = G_MAXINT;
 
-	while (start < wcount && !leftovers && !again) {
+	while (start < wcount && !leftovers) {
 		const char *match;
 		GQuark quark;
 		const gunichar *next;
@@ -3265,10 +3263,10 @@
 		if ((match != NULL) && (match[0] != '\0')) {
 			/* Call the right sequence handler for the requested
 			 * behavior. */
-			again = vte_terminal_handle_sequence(terminal,
-							     match,
-							     quark,
-							     params);
+			vte_terminal_handle_sequence(terminal,
+						     match,
+						     quark,
+						     params);
 			/* Skip over the proper number of unicode chars. */
 			start = (next - wbuf);
 			modified = TRUE;
@@ -3364,9 +3362,37 @@
 					screen->cursor_current.row);
 
 			/* Insert the character. */
-			_vte_terminal_insert_char(terminal, c,
+			if (G_UNLIKELY (_vte_terminal_insert_char(terminal, c,
 						 FALSE, FALSE,
-						 TRUE, 0);
+						 TRUE, 0))){
+				/* line wrapped, correct bbox */
+				if (invalidated_text &&
+						(screen->cursor_current.col > bbox_bottomright.x + VTE_CELL_BBOX_SLACK	||
+						 screen->cursor_current.col < bbox_topleft.x - VTE_CELL_BBOX_SLACK	||
+						 screen->cursor_current.row > bbox_bottomright.y + VTE_CELL_BBOX_SLACK	||
+						 screen->cursor_current.row < bbox_topleft.y - VTE_CELL_BBOX_SLACK)) {
+					/* Clip off any part of the box which isn't already on-screen. */
+					bbox_topleft.x = MAX(bbox_topleft.x, 0);
+					bbox_topleft.y = MAX(bbox_topleft.y, delta);
+					bbox_bottomright.x = MIN(bbox_bottomright.x,
+							terminal->column_count);
+					/* lazily apply the +1 to the cursor_row */
+					bbox_bottomright.y = MIN(bbox_bottomright.y + 1,
+							delta + terminal->row_count);
+
+					_vte_invalidate_cells(terminal,
+							bbox_topleft.x,
+							bbox_bottomright.x - bbox_topleft.x,
+							bbox_topleft.y,
+							bbox_bottomright.y - bbox_topleft.y);
+					bbox_bottomright.x = bbox_bottomright.y = -G_MAXINT;
+					bbox_topleft.x = bbox_topleft.y = G_MAXINT;
+
+				}
+				bbox_topleft.x = MIN(bbox_topleft.x, 0);
+				bbox_topleft.y = MIN(bbox_topleft.y,
+						screen->cursor_current.row);
+			}
 			/* Add the cells over which we have moved to the region
 			 * which we need to refresh for the user. */
 			bbox_bottomright.x = MAX(bbox_bottomright.x,
@@ -3418,23 +3444,6 @@
 		}
 	}
 
-	if (invalidated_text) {
-		/* Clip off any part of the box which isn't already on-screen. */
-		bbox_topleft.x = MAX(bbox_topleft.x, 0);
-		bbox_topleft.y = MAX(bbox_topleft.y, delta);
-		bbox_bottomright.x = MIN(bbox_bottomright.x,
-				terminal->column_count);
-		/* lazily apply the +1 to the cursor_row */
-		bbox_bottomright.y = MIN(bbox_bottomright.y + 1,
-				delta + terminal->row_count);
-
-		_vte_invalidate_cells(terminal,
-				bbox_topleft.x,
-				bbox_bottomright.x - bbox_topleft.x,
-				bbox_topleft.y,
-				bbox_bottomright.y - bbox_topleft.y);
-	}
-
 	/* Remove most of the processed characters. */
 	if (start < wcount) {
 		unichars = g_array_new(FALSE, FALSE, sizeof(gunichar));
@@ -3450,7 +3459,6 @@
 		/* If we're out of data, we needn't pause to let the
 		 * controlling application respond to incoming data, because
 		 * the main loop is already going to do that. */
-		again = FALSE;
 	}
 
 	if (modified) {
@@ -3486,6 +3494,26 @@
 		_vte_terminal_queue_contents_changed(terminal);
 	}
 
+	vte_terminal_emit_pending_signals (terminal);
+
+	if (invalidated_text) {
+		/* Clip off any part of the box which isn't already on-screen. */
+		bbox_topleft.x = MAX(bbox_topleft.x, 0);
+		bbox_topleft.y = MAX(bbox_topleft.y, delta);
+		bbox_bottomright.x = MIN(bbox_bottomright.x,
+				terminal->column_count);
+		/* lazily apply the +1 to the cursor_row */
+		bbox_bottomright.y = MIN(bbox_bottomright.y + 1,
+				delta + terminal->row_count);
+
+		_vte_invalidate_cells(terminal,
+				bbox_topleft.x,
+				bbox_bottomright.x - bbox_topleft.x,
+				bbox_topleft.y,
+				bbox_bottomright.y - bbox_topleft.y);
+	}
+
+
 	if ((cursor.col != terminal->pvt->screen->cursor_current.col) ||
 	    (cursor.row != terminal->pvt->screen->cursor_current.row)) {
 		/* invalidate the old and new cursor positions */
@@ -3517,7 +3545,6 @@
 			(long) unichars->len,
 			(long) _vte_incoming_chunks_length(terminal->pvt->incoming),
 			_vte_incoming_chunks_count(terminal->pvt->incoming));
-	return again;
 }
 
 static inline void
@@ -3643,7 +3670,7 @@
 	}
 
 	return !eof &&
-		(active_terminals ? g_list_length (active_terminals) : 1) *
+		g_list_length (active_terminals) *
 		terminal->pvt->input_bytes < terminal->pvt->max_input_bytes;
 }
 
@@ -3712,7 +3739,6 @@
 	}
 
 	if (_vte_buffer_length(terminal->pvt->outgoing) == 0) {
-		_vte_terminal_disconnect_pty_write(terminal);
 		leave_open = FALSE;
 	} else {
 		leave_open = TRUE;
@@ -7203,11 +7229,20 @@
 vte_terminal_fc_settings_changed(GtkSettings *settings, GParamSpec *spec,
 				 VteTerminal *terminal)
 {
+	PangoFontDescription *fontdesc;
+
 	_vte_debug_print(VTE_DEBUG_MISC,
 			"Fontconfig setting \"%s\" changed.\n",
 			spec->name);
-	vte_terminal_set_font_full(terminal, terminal->pvt->fontdesc,
+
+	/* force an update... */
+	fontdesc = terminal->pvt->fontdesc;
+	terminal->pvt->fontdesc = NULL;
+
+	vte_terminal_set_font_full(terminal, fontdesc,
 				   terminal->pvt->fontantialias);
+
+	pango_font_description_free(fontdesc);
 }
 
 /* Connect to notifications from our settings object that font hints have
@@ -9712,7 +9747,7 @@
 	if (col_stop == terminal->column_count)
 		rect.width = terminal->widget.allocation.width;
 	else
-		rect.width = col_stop*width;
+		rect.width = (col_stop + 1)*width;
 	rect.width -= rect.x;
 	if (row == 0)
 		rect.y = 0;
@@ -9721,7 +9756,7 @@
 	if (row_stop == terminal->row_count)
 		rect.height = terminal->widget.allocation.height;
 	else
-		rect.height = row_stop*height;
+		rect.height = (row_stop + 1)*height;
 	rect.height -= rect.y;
 	gdk_region_union_with_rect(region, &rect);
 
@@ -9748,16 +9783,14 @@
 	height = terminal->char_height;
 	delta = screen->scroll_delta;
 
-	/* increase the paint by one pixel on all sides to force the
-	 * inclusion of neighbouring cells */
 	row = MAX(0, (area->y - VTE_PAD_WIDTH) / height);
-	row_stop = MIN(howmany(area->height + area->y - VTE_PAD_WIDTH, height),
+	row_stop = MIN((area->height + area->y - VTE_PAD_WIDTH) / height,
 		       terminal->row_count);
 	if (row_stop <= row) {
 		return;
 	}
 	col = MAX(0, (area->x - VTE_PAD_WIDTH) / width);
-	col_stop = MIN(howmany(area->width + area->x - VTE_PAD_WIDTH, width),
+	col_stop = MIN((area->width + area->x - VTE_PAD_WIDTH) / width,
 		       terminal->column_count);
 	if (col_stop <= col) {
 		return;
@@ -9774,7 +9807,7 @@
 			(col_stop - col) * width,
 			(row_stop - row) * height);
 	if (!GTK_WIDGET_DOUBLE_BUFFERED (terminal) ||
-			_vte_draw_has_background_image (terminal->pvt->draw)) {
+			_vte_draw_requires_clear (terminal->pvt->draw)) {
 		_vte_draw_clear (terminal->pvt->draw,
 				area->x, area->y,
 				area->width, area->height);
@@ -9917,10 +9950,9 @@
 		item.y = row * height;
 		cursor_width = item.columns * width;
 		if (cell) {
-			cursor_width = MAX(cursor_width,
-					   _vte_draw_get_char_width(terminal->pvt->draw,
-								    cell->c,
-								    cell->columns));
+			gint cw = _vte_draw_get_char_width (terminal->pvt->draw,
+					cell->c, cell->columns);
+			cursor_width = MAX(cursor_width, cw);
 			cursor_width += cell->bold; /* pseudo-bolding */
 		}
 		_vte_draw_clear(terminal->pvt->draw,
@@ -10104,18 +10136,6 @@
 							FALSE,
 							TRUE,
 							width, height);
-			} else
-			if (preedit_cursor == len) {
-				/* Empty cursor at the end. */
-				vte_terminal_draw_cells(terminal,
-							&items[len], 1,
-							back, fore, TRUE, TRUE,
-							FALSE,
-							FALSE,
-							FALSE,
-							FALSE,
-							FALSE,
-							width, height);
 			}
 			g_free(items);
 		}
@@ -10130,14 +10150,19 @@
 vte_terminal_expose(GtkWidget *widget, GdkEventExpose *event)
 {
 	VteTerminal *terminal = VTE_TERMINAL (widget);
+	/* Beware the out of order events -
+	 *   do not even think about skipping exposes! */
 	_vte_debug_print (VTE_DEBUG_WORK, "+");
-	if (terminal->pvt->visibility_state == GDK_VISIBILITY_FULLY_OBSCURED) {
-		return FALSE;
-	}
 	_vte_debug_print (VTE_DEBUG_EVENTS, "Expose (%d,%d)x(%d,%d)\n",
 			event->area.x, event->area.y,
 			event->area.width, event->area.height);
 	if (terminal->pvt->active != NULL && !in_update_timeout) {
+		/* fix up a race condition where we schedule a delayed update
+		 * after an 'immediate' invalidate all */
+		if (terminal->pvt->invalidated_all &&
+				terminal->pvt->update_regions == NULL) {
+			terminal->pvt->invalidated_all = FALSE;
+		}
 		/* if we expect to redraw the widget soon,
 		 * just add this event to the list */
 		if (!terminal->pvt->invalidated_all) {
@@ -10163,6 +10188,7 @@
 {
 	GtkAdjustment *adj;
 	VteTerminal *terminal;
+	gdouble v;
 	glong new_value;
 	GdkModifierType modifiers;
 	int button;
@@ -10216,21 +10242,19 @@
 
 	/* Perform a history scroll. */
 	adj = terminal->adjustment;
-	new_value = terminal->pvt->screen->scroll_delta;
-
+	v = MAX (1., ceil (adj->page_increment / 10.));
 	switch (event->direction) {
 	case GDK_SCROLL_UP:
-		new_value -= MAX(1, adj->page_increment / 10);
+		v = -v;
 		break;
 	case GDK_SCROLL_DOWN:
-		new_value += MAX(1, adj->page_increment / 10);
 		break;
 	default:
 		return FALSE;
 	}
-
-	new_value = CLAMP(new_value, adj->lower,
-			MAX (adj->lower, adj->upper - adj->page_size));
+	v += terminal->pvt->screen->scroll_delta;
+	new_value = floor (CLAMP (v, adj->lower,
+				MAX (adj->lower, adj->upper - adj->page_size)));
 	vte_terminal_queue_adjustment_value_changed (terminal, new_value);
 
 	return TRUE;
@@ -12120,11 +12144,8 @@
 {
 	gdouble elapsed;
 	glong target;
-	gboolean again;
 	g_timer_reset (process_timer);
-	do {
-		again = vte_terminal_process_incoming (terminal);
-	} while (again);
+	vte_terminal_process_incoming (terminal);
 	elapsed = g_timer_elapsed (process_timer, NULL) * 1000;
 	target = VTE_MAX_PROCESS_TIME / elapsed * terminal->pvt->input_bytes;
 	terminal->pvt->max_input_bytes =
@@ -12174,12 +12195,11 @@
 			active = TRUE;
 			if (VTE_MAX_PROCESS_TIME && !multiple_active) {
 				time_process_incoming (terminal);
-			} else do {
-				again = vte_terminal_process_incoming(terminal);
-			} while (again);
+			} else {
+				vte_terminal_process_incoming(terminal);
+			}
 			terminal->pvt->input_bytes = 0;
 		}
-		vte_terminal_emit_pending_signals (terminal);
 		if (!active && terminal->pvt->update_regions == NULL) {
 			if (terminal->pvt->active != NULL) {
 				_vte_debug_print(VTE_DEBUG_TIMEOUT,
@@ -12292,18 +12312,18 @@
 			}
 			_vte_terminal_enable_input_source (terminal);
 		}
+		if (terminal->pvt->bg_update_pending) {
+			vte_terminal_background_update (terminal);
+		}
+		vte_terminal_emit_adjustment_changed (terminal);
 		if (need_processing (terminal)) {
 			if (VTE_MAX_PROCESS_TIME && !multiple_active) {
 				time_process_incoming (terminal);
-			} else do {
-				again = vte_terminal_process_incoming (terminal);
-			} while (again);
+			} else {
+				vte_terminal_process_incoming (terminal);
+			}
 			terminal->pvt->input_bytes = 0;
 		}
-		if (terminal->pvt->bg_update_pending) {
-			vte_terminal_background_update (terminal);
-		}
-		vte_terminal_emit_pending_signals (terminal);
 
 		again = update_regions (terminal);
 		if (!again) {
@@ -12376,7 +12396,6 @@
 	multiple_active = active_terminals->next != NULL;
 	for (l = active_terminals; l != NULL; l = next) {
 		VteTerminal *terminal = l->data;
-		gboolean again;
 
 		next = g_list_next (l);
 
@@ -12392,18 +12411,18 @@
 			}
 			_vte_terminal_enable_input_source (terminal);
 		}
+		if (terminal->pvt->bg_update_pending) {
+			vte_terminal_background_update (terminal);
+		}
+		vte_terminal_emit_adjustment_changed (terminal);
 		if (need_processing (terminal)) {
 			if (VTE_MAX_PROCESS_TIME && !multiple_active) {
 				time_process_incoming (terminal);
-			} else do {
-				again = vte_terminal_process_incoming (terminal);
-			} while (again);
+			} else {
+				vte_terminal_process_incoming (terminal);
+			}
 			terminal->pvt->input_bytes = 0;
 		}
-		if (terminal->pvt->bg_update_pending) {
-			vte_terminal_background_update (terminal);
-		}
-		vte_terminal_emit_pending_signals (terminal);
 
 		redraw |= update_regions (terminal);
 	}
diff -urN vte-0.16.0/src/vtedraw.c vte-1846/src/vtedraw.c
--- vte-0.16.0/src/vtedraw.c	2007-03-08 17:47:15.000000000 +0100
+++ vte-1846/src/vtedraw.c	2007-03-18 13:22:32.000000000 +0100
@@ -226,9 +226,9 @@
 }
 
 gboolean
-_vte_draw_has_background_image (struct _vte_draw *draw)
+_vte_draw_requires_clear (struct _vte_draw *draw)
 {
-	return draw->has_background_image;
+	return draw->requires_clear;
 }
 
 gboolean
diff -urN vte-0.16.0/src/vtedraw.h vte-1846/src/vtedraw.h
--- vte-0.16.0/src/vtedraw.h	2007-03-08 17:47:15.000000000 +0100
+++ vte-1846/src/vtedraw.h	2007-03-18 13:22:32.000000000 +0100
@@ -100,7 +100,7 @@
 	GtkWidget *widget;
 	gboolean started;
 	gint width, height, ascent;
-	gboolean has_background_image;
+	gboolean requires_clear;
 	const struct _vte_draw_impl *impl;
 	gpointer impl_data;
 };
@@ -132,7 +132,7 @@
 				    const char *file,
 				    const GdkColor *color,
 				    double saturation);
-gboolean _vte_draw_has_background_image (struct _vte_draw *draw);
+gboolean _vte_draw_requires_clear (struct _vte_draw *draw);
 gboolean _vte_draw_requires_repaint(struct _vte_draw *draw);
 gboolean _vte_draw_clip(struct _vte_draw *draw, GdkRegion *region);
 void _vte_draw_clear(struct _vte_draw *draw,
diff -urN vte-0.16.0/src/vteft2.c vte-1846/src/vteft2.c
--- vte-0.16.0/src/vteft2.c	2007-03-08 17:47:15.000000000 +0100
+++ vte-1846/src/vteft2.c	2007-03-18 13:22:32.000000000 +0100
@@ -164,7 +164,7 @@
 		g_object_unref(data->pixbuf);
 	}
 	data->pixbuf = bgpixbuf;
-	draw->has_background_image = bgpixbuf != NULL;
+	draw->requires_clear = bgpixbuf != NULL;
 }
 
 static void
diff -urN vte-0.16.0/src/vtegl.c vte-1846/src/vtegl.c
--- vte-0.16.0/src/vtegl.c	2007-03-08 17:47:15.000000000 +0100
+++ vte-1846/src/vtegl.c	2007-03-18 13:22:32.000000000 +0100
@@ -119,7 +119,6 @@
 	Display *display;
 	GdkScreen *gscreen;
 	int screen;
-	gboolean direct;
 
 	draw->impl_data = g_slice_new(struct _vte_gl_data);
 	data = (struct _vte_gl_data*) draw->impl_data;
@@ -152,6 +151,7 @@
 	data->buffer = _vte_buffer_new();
 
 	gtk_widget_set_double_buffered(widget, FALSE);
+	draw->requires_clear = TRUE;
 }
 
 static void
@@ -263,7 +263,6 @@
 		g_object_unref(data->bgpixbuf);
 	}
 	data->bgpixbuf = bgpixbuf;
-	draw->has_background_image = bgpixbuf != NULL;
 }
 
 static void
diff -urN vte-0.16.0/src/vtepango.c vte-1846/src/vtepango.c
--- vte-0.16.0/src/vtepango.c	2007-03-08 17:47:15.000000000 +0100
+++ vte-1846/src/vtepango.c	2007-03-18 13:22:32.000000000 +0100
@@ -175,13 +175,13 @@
 	if (data->pixmap != NULL) {
 		g_object_unref(data->pixmap);
 	}
-	draw->has_background_image = FALSE;
+	draw->requires_clear = FALSE;
 	data->pixmap = NULL;
 	data->pixmapw = data->pixmaph = 0;
 	if (pixmap) {
 		data->pixmap = pixmap;
 		gdk_drawable_get_size(pixmap, &data->pixmapw, &data->pixmaph);
-		draw->has_background_image =
+		draw->requires_clear =
 			data->pixmapw > 0 && data->pixmaph > 0;
 	}
 }
diff -urN vte-0.16.0/src/vtepangox.c vte-1846/src/vtepangox.c
--- vte-0.16.0/src/vtepangox.c	2007-03-08 17:47:15.000000000 +0100
+++ vte-1846/src/vtepangox.c	2007-03-18 13:22:32.000000000 +0100
@@ -208,13 +208,13 @@
 	if (data->pixmap != NULL) {
 		g_object_unref(data->pixmap);
 	}
-	draw->has_background_image = FALSE;
+	draw->requires_clear = FALSE;
 	data->pixmap = NULL;
 	data->pixmapw = data->pixmaph = 0;
 	if (pixmap != NULL) {
 		data->pixmap = pixmap;
 		gdk_drawable_get_size(pixmap, &data->pixmapw, &data->pixmaph);
-		draw->has_background_image =
+		draw->requires_clear =
 			data->pixmapw > 0 && data->pixmaph > 0;
 	}
 }
diff -urN vte-0.16.0/src/vte-private.h vte-1846/src/vte-private.h
--- vte-0.16.0/src/vte-private.h	2007-03-08 17:47:15.000000000 +0100
+++ vte-1846/src/vte-private.h	2007-03-18 13:22:32.000000000 +0100
@@ -395,7 +395,7 @@
 void _vte_terminal_queue_contents_changed(VteTerminal *terminal);
 void _vte_terminal_emit_text_deleted(VteTerminal *terminal);
 void _vte_terminal_emit_text_inserted(VteTerminal *terminal);
-void _vte_terminal_insert_char(VteTerminal *terminal, gunichar c,
+gboolean _vte_terminal_insert_char(VteTerminal *terminal, gunichar c,
 			       gboolean force_insert_mode,
 			       gboolean invalidate_cells,
 			       gboolean paint_cells,
diff -urN vte-0.16.0/src/vtexft.c vte-1846/src/vtexft.c
--- vte-0.16.0/src/vtexft.c	2007-03-08 17:47:15.000000000 +0100
+++ vte-1846/src/vtexft.c	2007-03-18 13:22:32.000000000 +0100
@@ -39,8 +39,6 @@
 #define FONT_INDEX_FUDGE 1
 #define CHAR_WIDTH_FUDGE 1
 
-#define DPY_FUDGE 1
-
 /* libXft will accept runs up to 1024 glyphs before allocating a temporary
  * array. However, setting this to a large value can cause dramatic slow-downs
  * for some xservers (notably fglrx), see bug 410534.
@@ -70,7 +68,6 @@
 	Visual *visual;
 	Colormap colormap;
 	XftDraw *draw;
-	GC gc;
 	GdkColor color;
 	guint16 opacity;
 	GdkPixmap *pixmap;
@@ -344,13 +341,16 @@
 _vte_xft_create (struct _vte_draw *draw, GtkWidget *widget)
 {
 	struct _vte_xft_data *data;
+
 	data = g_slice_new0 (struct _vte_xft_data);
 	draw->impl_data = data;
-	data->drawable = -1;
-	data->colormap = -1;
+
 	data->opacity = 0xffff;
+
 	data->xpixmap = -1;
 	data->pixmapw = data->pixmaph = -1;
+
+	data->drawable = -1;
 }
 
 static void
@@ -381,9 +381,6 @@
 	if (data->draw != NULL) {
 		XftDrawDestroy (data->draw);
 	}
-	if (data->gc != NULL) {
-		XFreeGC (data->display, data->gc);
-	}
 	g_slice_free (struct _vte_xft_data, data);
 }
 
@@ -402,8 +399,6 @@
 static void
 _vte_xft_start (struct _vte_draw *draw)
 {
-	GdkVisual *gvisual;
-	GdkColormap *gcolormap;
 	GdkDrawable *drawable;
 	GPtrArray *locked_fonts;
 	guint i;
@@ -411,33 +406,31 @@
 	struct _vte_xft_data *data;
 	data = (struct _vte_xft_data*) draw->impl_data;
 
+	gdk_error_trap_push ();
+
 	gdk_window_get_internal_paint_info (draw->widget->window,
 					   &drawable,
 					   &data->x_offs,
 					   &data->y_offs);
-
-	data->display = gdk_x11_drawable_get_xdisplay (drawable);
-	data->drawable = gdk_x11_drawable_get_xid (drawable);
-	gvisual = gdk_drawable_get_visual (drawable);
-	data->visual = gdk_x11_visual_get_xvisual (gvisual);
-	gcolormap = gdk_drawable_get_colormap (drawable);
-	data->colormap = gdk_x11_colormap_get_xcolormap (gcolormap);
-
-	g_assert (data->display == data->font->display);
-
-	gdk_error_trap_push ();
-
-	if (data->draw != NULL) {
-		XftDrawDestroy (data->draw);
-	}
-	data->draw = XftDrawCreate (data->display, data->drawable,
-				   data->visual, data->colormap);
-	if (data->gc != NULL) {
-		XFreeGC (data->display, data->gc);
+	if (data->drawable != gdk_x11_drawable_get_xid (drawable)) {
+		GdkVisual *gvisual;
+		GdkColormap *gcolormap;
+
+		if (data->draw != NULL) {
+			XftDrawDestroy (data->draw);
+		}
+		data->display = gdk_x11_drawable_get_xdisplay (drawable);
+		data->drawable = gdk_x11_drawable_get_xid (drawable);
+		gvisual = gdk_drawable_get_visual (drawable);
+		data->visual = gdk_x11_visual_get_xvisual (gvisual);
+		gcolormap = gdk_drawable_get_colormap (drawable);
+		data->colormap = gdk_x11_colormap_get_xcolormap (gcolormap);
+		data->draw = XftDrawCreate (data->display, data->drawable,
+				data->visual, data->colormap);
 	}
-	data->gc = XCreateGC (data->display, data->drawable, 0, NULL);
+	g_assert (data->display == data->font->display);
 
-	locked_fonts = data->locked_fonts [(++data->cur_locked_fonts)&1];
+	locked_fonts = data->locked_fonts [++data->cur_locked_fonts&1];
 	if (locked_fonts != NULL) {
 		guint cnt=0;
 		for (i = 1; i < locked_fonts->len; i++) {
@@ -457,16 +450,6 @@
 	struct _vte_xft_data *data;
 
 	data = (struct _vte_xft_data*) draw->impl_data;
-	if (data->draw != NULL) {
-		XftDrawDestroy (data->draw);
-		data->draw = NULL;
-	}
-	if (data->gc != NULL) {
-		XFreeGC (data->display, data->gc);
-		data->gc = NULL;
-	}
-	data->drawable = -1;
-	data->x_offs = data->y_offs = 0;
 
 	gdk_error_trap_pop ();
 }
@@ -479,6 +462,9 @@
 	data = (struct _vte_xft_data*) draw->impl_data;
 	data->color = *color;
 	data->opacity = opacity;
+
+	draw->requires_clear = opacity != 0xffff
+		|| (data->pixmapw > 0 && data->pixmaph > 0);
 }
 
 static void
@@ -505,13 +491,13 @@
 	if (data->pixmap != NULL) {
 		g_object_unref (data->pixmap);
 	}
-	draw->has_background_image = FALSE;
+	draw->requires_clear = data->opacity != 0xffff;
 	data->pixmap = NULL;
 	if (pixmap != NULL) {
 		data->pixmap = pixmap;
 		data->xpixmap = gdk_x11_drawable_get_xid (pixmap);
 		gdk_drawable_get_size (pixmap, &data->pixmapw, &data->pixmaph);
-		draw->has_background_image =
+		draw->requires_clear |=
 			data->pixmapw > 0 && data->pixmaph > 0;
 	}
 }
@@ -521,25 +507,24 @@
 		GdkRegion *region)
 {
 	struct _vte_xft_data *data = draw->impl_data;
+	XRectangle stack_rect[16];
+	XRectangle *xrect;
 	GdkRectangle *rect;
 	gint i, n;
 
 	gdk_region_get_rectangles (region, &rect, &n);
-	if (n>0) {
-		XRectangle *xrect = g_new (XRectangle, n);
-		for (i = 0; i < n; i++) {
-			/* we include the offset here as XftDrawSetClipRectangles () has a
-			 * byte-sex bug in its offset parameters. Bug 403159.
-			 */
-			xrect[i].x = rect[i].x - data->x_offs;
-			xrect[i].y = rect[i].y - data->y_offs;
-			xrect[i].width = rect[i].width;
-			xrect[i].height = rect[i].height;
-		}
-		XftDrawSetClipRectangles (data->draw,
-				0, 0, xrect, n);
-		g_free (xrect);
+	xrect = n > (gint) G_N_ELEMENTS (stack_rect) ?
+		g_new (XRectangle, n) :
+		stack_rect;
+	for (i = 0; i < n; i++) {
+		xrect[i].x = rect[i].x - data->x_offs;
+		xrect[i].y = rect[i].y - data->y_offs;
+		xrect[i].width = rect[i].width;
+		xrect[i].height = rect[i].height;
 	}
+	XftDrawSetClipRectangles (data->draw, 0, 0, xrect, n);
+	if (xrect != stack_rect)
+		g_free (xrect);
 	g_free (rect);
 }
 
@@ -551,6 +536,7 @@
 	XRenderColor rcolor;
 	XftColor ftcolor;
 	gint h, w, txstop, tystop, sx, sy, tx, ty;
+	GC gc;
 
 	data = (struct _vte_xft_data*) draw->impl_data;
 
@@ -580,6 +566,7 @@
 	tystop = y + height;
 
 	/* Flood fill. */
+	gc = XCreateGC (data->display, data->drawable, 0, NULL);
 	sy = (data->scrolly + y) % data->pixmaph;
 	while (ty < tystop) {
 		h = MIN (data->pixmaph - sy, tystop - ty);
@@ -590,7 +577,7 @@
 			XCopyArea (data->display,
 				  data->xpixmap,
 				  data->drawable,
-				  data->gc,
+				  gc,
 				  sx, sy,
 				  w, h,
 				  tx - data->x_offs, ty - data->y_offs);
@@ -600,6 +587,7 @@
 		ty += h;
 		sy = 0;
 	}
+	XFreeGC (data->display, gc);
 }
 
 static GPtrArray *
diff -urN vte-0.16.0/termcaps/xterm-color vte-1846/termcaps/xterm-color
--- vte-0.16.0/termcaps/xterm-color	1970-01-01 01:00:00.000000000 +0100
+++ vte-1846/termcaps/xterm-color	2007-03-18 13:22:43.000000000 +0100
@@ -0,0 +1,27 @@
+# This is a cut-down version of the termcap file from my box.
+
+xterm-color|generic "ANSI" color xterm (X Window System):\
+	:Co#8:NC@:pa#64:\
+	:AB=\E[4%dm:AF=\E[3%dm:op=\E[m:tc=xterm-r6:
+
+xterm-r6|xterm-old|xterm X11R6 version:\
+	:am:km:mi:ms:xn:\
+	:co#80:it#8:li#24:\
+	:@7=\E[4~:AL=\E[%dL:DC=\E[%dP:DL=\E[%dM:DO=\E[%dB:\
+	:F1=\E[23~:F2=\E[24~:F3=\E[25~:F4=\E[26~:F5=\E[28~:\
+	:F6=\E[29~:F7=\E[31~:F8=\E[32~:F9=\E[33~:FA=\E[34~:\
+	:Km=\E[M:LE=\E[%dD:RI=\E[%dC:UP=\E[%dA:ae=^O:al=\E[L:as=^N:\
+	:bl=^G:cd=\E[J:ce=\E[K:cl=\E[H\E[2J:cm=\E[%i%d;%dH:cr=^M:\
+	:cs=\E[%i%d;%dr:ct=\E[3g:dc=\E[P:dl=\E[M:do=^J:eA=\E)0:\
+	:ei=\E[4l:ho=\E[H:im=\E[4h:\
+	:is=\E7\E[r\E[m\E[?7h\E[?1;3;4;6l\E[4l\E8\E>:k1=\EOP:\
+	:k2=\EOQ:k3=\EOR:k4=\EOS:k5=\E[15~:k6=\E[17~:k7=\E[18~:\
+	:k8=\E[19~:k9=\E[20~:k;=\E[21~:kD=\177:kI=\E[2~:kN=\E[6~:\
+	:kP=\E[5~:kb=^H:kd=\EOB:ke=\E[?1l\E>:kh=\E[1~:kl=\EOD:\
+	:kr=\EOC:ks=\E[?1h\E=:ku=\EOA:le=^H:mb@:md=\E[1m:me=\E[m:\
+	:ml=\El:mr=\E[7m:mu=\Em:nd=\E[C:rc=\E8:\
+	:rs=\E7\E[r\E[m\E[?7h\E[?1;3;4;6l\E[4l\E8\E>:sc=\E7:\
+	:se=\E[m:sf=^J:so=\E[7m:sr=\EM:ta=^I:te=\E[2J\E[?47l\E8:\
+	:ti=\E7\E[?47h:u6=\E[%i%d;%dR:u7=\E[6n:u8=\E[?1;2c:\
+	:u9=\E[c:ue=\E[m:up=\E[A:us=\E[4m:
+
